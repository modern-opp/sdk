%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert
%locations

%code requires {
#include <iostream>
#include <string>

namespace yy {

    class parser;

}
}

%code {    
namespace yy {

    parser::symbol_type yylex();

}

extern yy::parser::symbol_type get_next_token();
}

%token IDENTIFIER BOOLEAN_LITERAL INTEGER_LITERAL REAL_LITERAL STRING_LITERAL CLASS EXTENDS IS END THIS METHOD LEFT_PAREN RIGHT_PAREN COLON COMMA METHOD_DEFINITION RETURN VAR ASSIGNMENT_OPERATOR MEMBER_ACCESS_OPERATOR IF THEN ELSE WHILE LOOP
%type <std::string> IDENTIFIER
%type <bool> BOOLEAN_LITERAL
%type <int> INTEGER_LITERAL
%type <double> REAL_LITERAL
%type <std::string> STRING_LITERAL

%%

program: class_declaration_list function_call;

class_declaration_list:
    class_declaration_list class_declaration
  | %empty
;

class_declaration:
    CLASS class_name EXTENDS class_name IS member_declaration_list END
  | CLASS class_name IS member_declaration_list END
;

class_name: IDENTIFIER;

member_declaration_list:
    member_declaration_list member_declaration
  | %empty
;

member_declaration:
    variable_declaration
  | method_declaration
  | constructor_declaration
;

variable_declaration: VAR IDENTIFIER COLON expression;

method_declaration:
    method_header method_body
  | method_header
;

method_header:
    METHOD IDENTIFIER parameters COLON IDENTIFIER
  | METHOD IDENTIFIER parameters
;

method_body:
    IS body_list END
  | METHOD_DEFINITION return_statement
  | METHOD_DEFINITION expression
;

parameters: LEFT_PAREN parameter_declaration_list RIGHT_PAREN;

parameter_declaration_list:
    parameter_declaration_list COMMA parameter_declaration
  | %empty
;

parameter_declaration: IDENTIFIER COLON class_name;

body_list:
    body_list body
  | %empty
;

body:
    variable_declaration
  | statement
;

constructor_declaration: THIS parameters IS body_list END;

statement:
    assignment
  | while_loop
  | if_statement
  | return_statement
;

assignment: IDENTIFIER ASSIGNMENT_OPERATOR expression;

while_loop: WHILE expression LOOP body_list END;

if_statement:
    IF expression THEN body_list ELSE body_list END;
  | IF expression THEN body_list END
;

return_statement: RETURN expression;

expression_list:
    expression_list COMMA expression
  | %empty
;

expression:
    primary
  | member_access_list MEMBER_ACCESS_OPERATOR function_call
  | function_call
;

primary:
    BOOLEAN_LITERAL
  | INTEGER_LITERAL
  | REAL_LITERAL
  | STRING_LITERAL
  | THIS
;

member_access_list:
    member_access_list MEMBER_ACCESS_OPERATOR member_access
  | member_access
;

member_access:
    primary
  | function_call
;

function_call: IDENTIFIER arguments;

arguments: LEFT_PAREN expression_list RIGHT_PAREN;

%%

namespace yy {

void parser::error(const location_type& loc, const std::string& msg) {
    std::cerr << "syntax error on " << loc << "!" << std::endl;
}

}
